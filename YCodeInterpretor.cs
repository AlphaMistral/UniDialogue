//
// Copyright (c) 20015-2017 Jingping Yu.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

using UnityEngine;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using SQLite4Unity3d;

namespace Mistral.UniDialogue
{
	/// <summary>
	/// Token types.
	/// </summary>
	public enum TokenType
	{
		VAR, CONST, FUNC, EXPR, 
		SEMICOLON, L_BRACKET, R_BRACKET, LS_BRACKET, RS_BRACKET, COMMA, 
		PLUS, MINUS, MUL, DIV, POW, DPLUS, DMINUS, 
		PLUSEQ, MINUSEQ, MULEQ, DIVEQ, POWEQ, 
		AND, OR, NOT, 
		MORE, LESS, EQUAL, 
		MOREEQ, LESSEQ, NOTEQUAL, EQUALEQ, 
		NONTOKEN,
		ERRTOKEN
	}
	
	/// <summary>
	/// A single grammar node of YCode. 
	/// Generated by YCodeScanner. 
	/// More Basically ... Token. 
	/// </summary>
	public class YCodeNode
	{
		#region Public Variables
		
		/// <summary>
		/// The type of token.
		/// </summary>
		public TokenType type;
		
		/// <summary>
		/// The original code. 
		/// </summary>
		public string lexicon;
		
		/// <summary>
		/// The value of the node. 
		/// </summary>
		public object value;
		
		#endregion
		
		#region Constructors 
		
		public YCodeNode ()
		{
			type = TokenType.NONTOKEN;
			lexicon = "";
			value = null;
		}
		
		public YCodeNode (TokenType t, string l, object v)
		{
			type = t;
			lexicon = l;
			value = v;
		}
		
		#endregion
	}
	
	/// <summary>
	/// The grammar scanner of the YCode. Singleton. 
	/// </summary>
	public static class YCodeScanner
	{
		#region Private Variables
		
		/// <summary>
		/// The error messages generated during the analysis. 
		/// </summary>
		private static List<string> errorMessages;
		
		/// <summary>
		/// Points to the index of the character to be analyzed. 
		/// </summary>
		private static int currentPointer;
		
		/// <summary>
		/// The original sentence to be analyzed. 
		/// </summary>
		private static string code;
		
		/// <summary>
		/// The Buffer of the stored token. 
		/// </summary>
		private static string tokenBuffer;
		
		#endregion
		
		#region Error Types
		
		public enum ErrorType
		{
			InvalidNumber,
			
		}
		
		#endregion
		
		#region Public Methods
		
		/// <summary>
		/// Analyze the given sentence and split the sentence into tokens and nodes.
		/// </summary>
		/// <returns>The sentence.</returns>
		/// <param name="sentence">Sentence.</param>
		public static List<YCodeNode> AnalyzeSentence (string sentence)
		{
			Initialize(sentence);
			
			List<YCodeNode> ret = new List<YCodeNode>();
			
			///Inserts all the possible nodes in the sentence. 
			while (!isFinished())
			{
				ret.Add(GetNode());
			}
			
			return ret;
		}
		
		#endregion
		
		#region Private Methods
		
		/// <summary>
		/// Initialize the scanner.
		/// </summary>
		/// <param name="sentence">Sentence.</param>
		private static void Initialize (string sentence)
		{
			code = sentence;
			tokenBuffer = "";
			errorMessages.Clear();
			currentPointer = 0;
		}
		
		/// <summary>
		/// Get the next Valid Char and auto-increase the poiter. 
		/// Safe Function. Never Triggers runtime error. 
		/// </summary>
		/// <returns>The char.</returns>
		private static char GetChar ()
		{
			///Ignores all the spaces. 
			while (code[currentPointer] == ' ' && currentPointer < code.Length)
			{
				currentPointer++;
			}
			
			if (currentPointer == code.Length)
				return '\0';
			else 
				return code[currentPointer++];
		}
		
		/// <summary>
		/// Backspaces for one single character. 
		/// </summary>
		private static void BackSpaceChar ()
		{
			if (currentPointer != 0)
				currentPointer--;
		}
		
		/// <summary>
		/// Whether the analysis should finish or not. 
		/// </summary>
		/// <returns><c>true</c>, if finished was ised, <c>false</c> otherwise.</returns>
		private static bool isFinished ()
		{
			return currentPointer >= code.Length;
		}
		
		/// <summary>
		/// Get the nearest node according to the currentPointer. 
		/// Meanwhile generates error messages. 
		/// </summary>
		/// <returns>The node.</returns>
		private static YCodeNode GetNode ()
		{
			YCodeNode node;
			
			tokenBuffer = "";
			
			char c = GetChar();
			
			if (char.IsLetter(c))
			{
				node = LetterNode(c);
			}
			else if (char.IsDigit(c))
			{
				node = DigitNode(c);
			}
			else if (c == '&' || c == '|' || c == '!')
			{
				node = LogicNode(c);
			}
			else if (c == '+' || c == '-' || c == '*' || c == '/' || c == '^')
			{
				node = OperatorNode(c);
			}
			else if (c == '>' || c == '=' || c == '<')
			{
				node = CompareNode(c);
			}
			else if (c == '(')
			{
				node = ExprNode(c);
			}
			else
			{
				node = new YCodeNode(TokenType.ERRTOKEN, ")", null);
				///Call for generating Error. 
			}
			return node;
		}
		
		#endregion
		
		#region Node Generating
		
		private static YCodeNode LetterNode (char c)
		{
			YCodeNode node = new YCodeNode();
			
			while (char.IsLetterOrDigit(c))
			{
				tokenBuffer += c;
				c = GetChar();
			}

			BackSpaceChar();

			if (c == '(')
			{
				///This is a Function. 
				node.type = TokenType.FUNC;
			}
			else
			{
				///This is a Variable. 
				node.type = TokenType.VAR;
			}

			node.lexicon = tokenBuffer;
			node.value = YCodeVariableBuffer.GetVariable(node.lexicon);
			
			return node;
		}
		
		private static YCodeNode DigitNode (char c)
		{
			YCodeNode node = new YCodeNode();
			
			node.type = TokenType.CONST;

			while (char.IsDigit(c) || c == '.')
			{
				tokenBuffer += c;
				c = GetChar();
			}

			BackSpaceChar();

			node.lexicon = tokenBuffer;
			
			float v;
			
			if (!float.TryParse(node.lexicon, out v))
			{
				///The Number is invalid. Set the value to null and generate error message. 
				node.value = null;

				AppendErrorMessage(node, ErrorType.InvalidNumber);
			}
			else
			{
				node.value = v;
			}
			return node;
		}
		
		public static YCodeNode LogicNode (char c)
		{
			YCodeNode node = new YCodeNode();
			
			node.value = (float)0f;
			
			tokenBuffer += c;
			
			switch (c)
			{
				case '&': 
					node.type = TokenType.AND;
					c = GetChar();
					if (c != '&')
					{
						node.value = null;
						///Error Message. 
					}
					else
					{
						tokenBuffer += c;
						BackSpaceChar();
					}
					break;
					
				case '|':
					node.type = TokenType.OR;
					c = GetChar();
					if (c != '|')
					{
						node.value = null;
						///Error Message. 
					}
					else
					{
						tokenBuffer += c;
						BackSpaceChar();
					}
					break;
					
				case '!':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.NOTEQUAL;
					}
					else
					{
						node.type = TokenType.NOT;
						BackSpaceChar();
					}
					break;
					
				default: 
					///Actually, this is impossible ... 
					break;
			}
			node.lexicon = tokenBuffer;
			
			return node;
		}
		
		public static YCodeNode OperatorNode (char c)
		{
			YCodeNode node = new YCodeNode();
			
			tokenBuffer += c;
			node.value = (float)0f;
			
			switch (c)
			{
				case '+':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.PLUSEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.PLUS;
						BackSpaceChar();
					}
					break;
				case '-':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.MINUSEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.MINUS;
						BackSpaceChar();
					}
					break;
				case '*':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.MULEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.MUL;
						BackSpaceChar();
					}
					break;
				case '/':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.DIVEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.DIV;
						BackSpaceChar();
					}
					break;
				case '^':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.POWEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.POW;
						BackSpaceChar ();
					}
					break;
			}
			
			node.lexicon = tokenBuffer;
			
			return node;
		}
		
		public static YCodeNode CompareNode (char c)
		{
			YCodeNode node = new YCodeNode();
			
			tokenBuffer += c;
			
			switch (c)
			{
				case '>':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.MOREEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.MORE;
						BackSpaceChar();
					}
					break;
				case '<':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.LESSEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.LESS;
						BackSpaceChar();
					}
					break;
				case '=':
					c = GetChar();
					if (c == '=')
					{
						node.type = TokenType.EQUALEQ;
						tokenBuffer += '=';
					}
					else
					{
						node.type = TokenType.EQUAL;
						BackSpaceChar();
					}
					break;
			}
			
			node.lexicon = tokenBuffer;
			
			return node;
		}
		
		public static YCodeNode ExprNode (char c)
		{
			YCodeNode node = new YCodeNode();
			
			tokenBuffer += c;
			
			c = GetChar();
			
			int lBracket = 1, rBracket = 0;
			
			while (lBracket != rBracket && c != '\0')
			{
				if (c == '(')
					lBracket++;
				else if (c == ')')
					rBracket++;
				
				tokenBuffer += c;
				
				c = GetChar();
			}
			
			if (lBracket != rBracket)
				node.value = null;
			else
				node.value = (float)0f;
			
			node.lexicon = tokenBuffer;
			
			return node;
		}
		
		#endregion
		
		#region Error Message
		
		/// <summary>
		/// Appends the Error Message to the List. 
		/// </summary>
		/// <param name="node">Node.</param>
		/// <param name="errType">Error type.</param>
		public static void AppendErrorMessage (YCodeNode node, ErrorType errType)
		{
			
		}
		
		public static void AppendExpection (string expected, string found)
		{
			
		}
		
		#endregion
	}
	
	/// <summary>
	/// Stores and manages all the variables for the YCode running environment. 
	/// </summary>
	public static class YCodeVariableBuffer
	{
		#region Public Variables
		
		
		
		#endregion
		
		#region Public Methods
		
		public static object GetVariable (string _varName)
		{
			return null;
		}
		
		#endregion
	}
}
